'use strict';
const checkType = require('./type');
const numberUtils = require('./number');

const isArray = checkType.isArray;
const AP = Array.prototype;
const slice = AP.slice;

function isArrayLike(arr) {
  return typeof arr === 'object' && numberUtils.isFinite(arr.length);
}
function toArray(arr) {
  return isArrayLike(arr) ? slice.call(arr) : [];
}

function arrayFromSecondElement(arr) {
  return slice.call(arr, 1);
}
function applyNativeFunction(nativeFunction, target, args) {
  return nativeFunction.apply(target, arrayFromSecondElement(args));
}

// index
const index = up => (arr, searchElement, fromIndex) => {
  let i;
  const len = arr.length >>> 0;
  if (len === 0) {
    return -1;
  }
  if (!fromIndex) {
    fromIndex = up ? 0 : arr.length;
  } else if (fromIndex < 0) {
    fromIndex = Math.max(0, arr.length + fromIndex);
  }
  if (up) {
    for (i = fromIndex; i < arr.length; i++) {
      if (arr[i] === searchElement) {
        return i;
      }
    }
  } else {
    for (i = fromIndex; i >= 0; i--) {
      if (arr[i] === searchElement) {
        return i;
      }
    }
  }
  return -1;
};
const indexOf = AP.indexOf ? function indexOf(arr) {
  return applyNativeFunction(AP.indexOf, arr, arguments);
} : index(true);
const lastIndexOf = AP.lastIndexOf ? function lastIndexOf(arr) {
  return applyNativeFunction(AP.lastIndexOf, arr, arguments);
} : index();

// each
const each = AP.forEach ? function each(arr/* , callback, thisObj */) {
  applyNativeFunction(AP.forEach, arr, arguments);
} : function each(arr, callback, thisObj) {
  const a = toArray(arr);
  for (let i = 0; i < a.length; i++) {
    callback.call(thisObj, a[i], i, arr);
  }
};

// every
const every = AP.every ? function every(arr) {
  return applyNativeFunction(AP.every, arr, arguments);
} : (arr, callback, thisObj) => {
  const a = toArray(arr);
  for (let i = 0; i < a.length; i++) {
    if (!callback.call(thisObj, a[i], i, arr)) {
      return false;
    }
  }
  return true;
};

// filter
const filter = AP.filter ? function filter(arr) {
  return applyNativeFunction(AP.filter, arr, arguments);
} : (arr, callback, thisObj) => {
  const res = [];
  each(arr, (element, key) => {
    if (callback.call(thisObj, element, key, arr)) {
      res.push(element);
    }
  });
  return res;
};

// map
const map = AP.map ? function map(arr) {
  return applyNativeFunction(AP.map, arr, arguments);
} : (arr, callback, thisObj) => {
  const res = [];
  each(arr, (element, key) => {
    res.push(callback.call(thisObj, element, key, arr));
  });
  return res;
};

// some
const some = AP.some ? function some(arr) {
  return applyNativeFunction(AP.some, arr, arguments);
} : (arr, callback, thisObj) => {
  let i;
  for (i = 0; i < arr.length; i++) {
    if (callback.call(thisObj, arr[i], i, arr)) {
      return true;
    }
  }
  return false;
};

// reduce
const reduce = AP.reduce ? function reduce(arr) {
  return applyNativeFunction(AP.reduce, arr, arguments);
} : (arr, callback, thisObj) => {
  let value;
  if (thisObj) {
    value = thisObj;
  }
  for (let i = 0; i < arr.length; i++) {
    if (value) {
      value = callback(value, arr[i], i, arr);
    } else {
      value = arr[i];
    }
  }
  return value;
};

// reduceRight
const reduceRight = AP.reduceRight ? function reduceRight(arr) {
  return applyNativeFunction(AP.reduceRight, arr, arguments);
} : (arr, callback, thisObj) => {
  let value;
  if (thisObj) {
    value = thisObj;
  }
  for (let i = arr.length - 1; i >= 0; i--) {
    if (value) {
      value = callback(value, arr[i], i, arr);
    } else {
      value = arr[i];
    }
  }
  return value;
};

// contains
function contains(arr, value) {
  return indexOf(toArray(arr), value) > -1;
}

// uniq
function uniq(arr) {
  const resultArr = [];
  each(arr, (element) => {
    if (!contains(resultArr, element)) {
      resultArr.push(element);
    }
  });
  return resultArr;
}

// flatten
function flatten(arr) {
  const a = toArray(arr);
  let r = [];
  for (let i = 0, l = a.length; i < l; ++i) {
    if (isArrayLike(a[i])) {
      r = r.concat(a[i]);
    } else {
      r[r.length] = a[i];
    }
  }
  return r;
}

const arrayUtils = {
  contains,
  each,
  every,
  filter,
  flatten,
  index,
  indexOf,
  isArray,
  isArrayLike,
  lastIndexOf,
  map,
  reduce,
  reduceRight,
  some,
  toArray,
  uniq,
  forEach: each,
  difference(arr) {
    const rest = flatten(arrayFromSecondElement(arguments));
    return filter(arr, (value) => !contains(rest, value));
  },
  eachReverse(arr, callback, thisObj) {
    const a = toArray(arr);
    let i = a.length - 1;
    for (; i > -1; i -= 1) {
      callback.call(thisObj, a[i], i, arr);
    }
  },
  intersect(a, b) {
    const result = [];
    each(a, (value) => {
      if (contains(b, value)) {
        result.push(value);
      }
    });
    return result;
  },
  range(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    if (!step) {
      step = stop < start ? -1 : 1;
    }
    const length = Math.max(Math.ceil((stop - start) / step), 0);
    const range = new Array(length);
    for (let i = 0; i < length; i++, start += step) {
      range[i] = start;
    }
    return range;
  },
  remove(arr, fromIndex, toIndex) {
    const len = arr.length;
    if (!numberUtils.isNumber(fromIndex)) {
      return arr;
    }
    const rest = arr.slice((toIndex || fromIndex) + 1 || len);
    arr.length = fromIndex < 0 ? len + fromIndex : fromIndex;
    return arr.push.apply(arr, rest);
  },
  union() {
    let resultArr = [];
    const sourceArrs = toArray(arguments);
    each(sourceArrs, (arr) => {
      resultArr = resultArr.concat(arr);
    });
    return uniq(resultArr);
  }
};

module.exports = arrayUtils;

