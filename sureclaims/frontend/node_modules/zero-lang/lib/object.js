'use strict';
const checkType = require('./type');
const getType = checkType.getType;
const isFunction = checkType.isFunction;
const isObject = checkType.isObject;
const isPlainObject = checkType.isPlainObject;

const arrayUtils = require('./array');
const contains = arrayUtils.contains;
const each = arrayUtils.each;
const isArrayLike = arrayUtils.isArrayLike;
const toArray = arrayUtils.toArray;

function toPlainObject(obj) {
  return isPlainObject(obj) ? obj : {};
}
function forIn(obj, callback, thisObj) {
  const plainObj = toPlainObject(obj);
  for (const key in plainObj) {
    if ({}.hasOwnProperty.call(plainObj, key)) {
      callback.call(thisObj, plainObj[key], key, obj);
    }
  }
}

const keys = Object.keys ? obj => Object.keys(obj) : obj => {
  const result = [];
  forIn(obj, (value, key) => {
    if (!(isFunction(obj) && key === 'prototype')) {
      result.push(key);
    }
  });
  return result;
};

function values(obj) {
  const result = [];
  forIn(obj, (value) => {
    result.push(value);
  });
  return result;
}

function extend(dest) {
  dest = dest || {};
  each(toArray(arguments).slice(1), (source) => {
    if (source) {
      forIn(source, (value, key) => {
        dest[key] = source[key];
      });
    }
  });
  return dest;
}

function merge(dest) {
  dest = dest || {};
  each(toArray(arguments).slice(1), (source) => {
    forIn(source, (value, prop) => {
      if (getType(source[prop]) !== getType(dest[prop])) {
        if (isPlainObject(source[prop])) {
          dest[prop] = {};
          merge(dest[prop], source[prop]);
        } else {
          dest[prop] = source[prop];
        }
      } else {
        if (isPlainObject(source[prop])) {
          merge(dest[prop], source[prop]);
        } else {
          dest[prop] = source[prop];
        }
      }
    });
  });
  return dest;
}

const objectUtils = {
  extend,
  forIn,
  isObject,
  isPlainObject,
  keys,
  merge,
  values,
  assign: extend,
  hasKey(obj, key) {
    return {}.hasOwnProperty.call(obj, key);
  },
  hasValue: (obj, value) => contains(values(obj), value),
  invert(obj) {
    const result = {};
    forIn(obj, (value, key) => {
      result[value] = key;
    });
    return result;
  },
  clone(obj) {
    if (isArrayLike(obj)) {
      return toArray(obj);
    }
    if (isPlainObject(obj)) {
      return merge({}, obj);
    }
    return obj;
  },
  destroy(obj) {
    forIn(obj, (value, key) => {
      delete obj[key];
    });
    obj.prototype = null;
    obj = null;
  }
};

module.exports = objectUtils;

